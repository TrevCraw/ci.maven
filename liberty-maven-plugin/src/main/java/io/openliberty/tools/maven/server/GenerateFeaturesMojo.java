/**
 * (C) Copyright IBM Corporation 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.openliberty.tools.maven.server;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;



import org.apache.maven.artifact.Artifact;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.DependencyManagement;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;
import org.codehaus.mojo.pluginsupport.util.ArtifactItem;
import org.eclipse.aether.collection.CollectRequest;
import org.eclipse.aether.collection.CollectResult;
import org.eclipse.aether.collection.DependencyCollectionException;
import org.eclipse.aether.resolution.DependencyResolutionException;

import io.openliberty.tools.common.plugins.config.ServerConfigDropinXmlDocument;
import io.openliberty.tools.common.plugins.util.InstallFeatureUtil;
import io.openliberty.tools.common.plugins.util.InstallFeatureUtil.ProductProperties;
import io.openliberty.tools.common.plugins.util.PluginExecutionException;
import io.openliberty.tools.common.plugins.util.PluginScenarioException;
import io.openliberty.tools.maven.BasicSupport;
import io.openliberty.tools.maven.InstallFeatureSupport;

//import org.apache.maven.shared.dependency.analyzer.DefaultProjectDependencyAnalyzer;
//import org.apache.maven.shared.dependency.analyzer.DependencyAnalyzer;

import org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalysis;
import org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalyzer;
import org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalyzerException;

import org.codehaus.plexus.PlexusContainer;
import org.codehaus.plexus.DefaultPlexusContainer;
import org.codehaus.plexus.PlexusConstants;
import org.codehaus.plexus.context.Context;

/**
 * This mojo generates the features required in the featureManager element in server.xml.
 * It examines the dependencies declared in the pom.xml and the features already declared
 * in the featureManager elements in the XML configuration files. Then it generates any
 * missing feature names and stores them in a new featureManager element in a new XML file.
 */
@Mojo(name = "generate-features", requiresDependencyCollection = ResolutionScope.TEST, requiresDependencyResolution = ResolutionScope.TEST)
public class GenerateFeaturesMojo extends InstallFeatureSupport {

    protected static final String PLUGIN_ADDED_FEATURES_FILE = "configDropins/overrides/liberty-plugin-added-features.xml";
    protected static final String HEADER = "# Generated by liberty-maven-plugin";

    @Parameter(property = "filterDependency", defaultValue = "false")
    private boolean filterDependency;

    @Parameter(property = "includes")
    private String includes;

    @Parameter(property = "analyzeDependencies", defaultValue = "false")
    private boolean analyzeDependencies;

    @Parameter(property = "buildPOMDependencyTrees", defaultValue = "false")
    private boolean buildPOMDependencyTrees;

    @Parameter(property = "buildUmbrellaDependencyTrees", defaultValue = "false")
    private boolean buildUmbrellaDependencyTrees;

    @Parameter(property = "findDependencyVersion", defaultValue = "false")
    private boolean findDependencyVersion;

    @Parameter(property = "packageDep")
    private String packageDep;

    @Parameter(property = "umbrellaDep")
    private String umbrellaDep;

    //private Context context;

    /*
     * (non-Javadoc)
     * @see org.codehaus.mojo.pluginsupport.MojoSupport#doExecute()
     */
    @Override
    protected void doExecute() throws Exception {
        if (filterDependency) {
            filterDependency(includes);
        } else if (analyzeDependencies) {
            dependencyAnalysis();
        } else if (buildPOMDependencyTrees) {
            buildPOMDependencyTrees();
        } else if (buildUmbrellaDependencyTrees) {
            buildUmbrellaDependencyTrees();
        } else if (findDependencyVersion) {
            findDependencyVersion(packageDep, umbrellaDep);
        } else {
            if(!initialize()) {
                return;
            }
            generateFeatures();
        }
    }

    private void generateFeatures() throws PluginExecutionException {
        log.warn("warn");
        List<ProductProperties> propertiesList = InstallFeatureUtil.loadProperties(installDirectory);
        String openLibertyVersion = InstallFeatureUtil.getOpenLibertyVersion(propertiesList);
        log.warn("version:"+openLibertyVersion);

        InstallFeatureMojoUtil util;
        try {
            util = new InstallFeatureMojoUtil(new HashSet<String>(), propertiesList, openLibertyVersion, null);
        } catch (PluginScenarioException e) {
            log.debug("Exception creating the server utility object", e);
            log.error("Error attempting to generate server feature list.");
            return;
        }

        Set<String> visibleServerFeatures = util.getAllServerFeatures();
        log.warn("feature count="+visibleServerFeatures.size());

        Set<String> libertyFeatureDependencies = getFeaturesFromDependencies(project);
        log.warn("maven dependencies that are liberty features:"+libertyFeatureDependencies);

        // Remove project dependency features which are hidden.
        Set<String> visibleLibertyProjectDependencies = new HashSet<String>(libertyFeatureDependencies);
        visibleLibertyProjectDependencies.retainAll(visibleServerFeatures);
        log.warn("maven dependencies that are VALID liberty features:"+visibleLibertyProjectDependencies);

        File newServerXml = new File(serverDirectory, PLUGIN_ADDED_FEATURES_FILE);
        log.warn("New server xml file:"+newServerXml+". Now to delete this file if it exists.");
        newServerXml.delete(); // about to regenerate this file. Must be removed before getLibertyDirectoryPropertyFiles

        Map<String, File> libertyDirPropertyFiles;
        try {
            libertyDirPropertyFiles = BasicSupport.getLibertyDirectoryPropertyFiles(installDirectory, userDirectory, serverDirectory);
        } catch (IOException e) {
            // TODO restore the xml file just deleted above
            log.debug("Exception reading the server property files", e);
            log.error("Error attempting to generate server feature list. Ensure you can read the property files in the server installation directory.");
            return;
        }
        Set<String> existingFeatures = util.getServerFeatures(serverDirectory, libertyDirPropertyFiles);
        log.warn("Features in server.xml:"+existingFeatures);

        Set<String> missingLibertyFeatures = getMissingLibertyFeatures(visibleLibertyProjectDependencies,
				existingFeatures);
        log.warn("maven dependencies that are VALID liberty features but are missing from server.xml:"+missingLibertyFeatures);

        // Create specialized server.xml
        try {
            ServerConfigDropinXmlDocument configDocument = ServerConfigDropinXmlDocument.newInstance();
            configDocument.createComment(HEADER);
            for (String missing : missingLibertyFeatures) {
                log.warn("adding missing feature:"+missing);
                configDocument.createFeature(missing);
            }
            configDocument.writeXMLDocument(newServerXml);
            log.warn("Created file "+newServerXml);
        } catch(ParserConfigurationException | TransformerException | IOException e) {
            log.debug("Exception creating the server features file", e);
            log.error("Error attempting to create the server feature file. Ensure you can write to the server installation directory.");
            return;
        }
    }

    /**
     * Comb through the list of Maven project dependencies and find the ones which are 
     * Liberty features.
     * @param project  Current Maven project
     * @return List of names of dependencies
     */
    private Set<String> getFeaturesFromDependencies(MavenProject project) {
        Set<String> libertyFeatureDependencies = new HashSet<String>();
        List<Dependency> allProjectDependencies = project.getDependencies();
        for (Dependency d : allProjectDependencies) {
            String featureName = getFeatureName(d);
            if (featureName != null) {
                libertyFeatureDependencies.add(featureName);
            }
        }
        return libertyFeatureDependencies;
    }

    /**
     * From all the candidate project dependencies remove the ones already in server.xml
     * to make the list of the ones that are missing from server.xml.
     * @param visibleLibertyProjectDependencies
     * @param existingFeatures
     * @return
     */
	private Set<String> getMissingLibertyFeatures(Set<String> visibleLibertyProjectDependencies,
			Set<String> existingFeatures) {
		Set<String> missingLibertyFeatures = new HashSet<String>(visibleLibertyProjectDependencies);
        if (existingFeatures != null) {
            for (String s : visibleLibertyProjectDependencies) {
                // existingFeatures are all lower case
                if (existingFeatures.contains(s.toLowerCase())) {
                    missingLibertyFeatures.remove(s);
                }
            }
        }
		return missingLibertyFeatures;
	}

	/**
	 * Determine if a dependency is a Liberty feature or not
	 * @param mavenDependency  a Maven project dependency 
	 * @return the Liberty feature name if the input is a Liberty feature otherwise return null.
	 */
    private String getFeatureName(Dependency mavenDependency) {
        if (mavenDependency.getGroupId().equals("io.openliberty.features")) {
            return mavenDependency.getArtifactId();
        }
        return null;
    }

    private void buildPOMDependencyTrees() throws DependencyResolutionException, MojoExecutionException {
        log.debug("<<<<<<<<<<<< Building POM Dependency Trees >>>>>>>>>>>");
        DependencyManagement dm = project.getDependencyManagement();
        List<Dependency> dependencies;
        if (dm != null) {
            dependencies = dm.getDependencies();
        }
        else {
            log.debug("DependencyManagement is null. Retrieve dependencies directly through project.");
            dependencies = project.getDependencies();
        }
        List<Artifact> artifacts = new ArrayList<Artifact>();
        for (Dependency dep : dependencies) {
            ArtifactItem item = new ArtifactItem();
            item.setGroupId(dep.getGroupId());
            item.setArtifactId(dep.getArtifactId());
            // force the collection to get only the pom, not the actual artifact type
            item.setType("pom");
            item.setVersion(dep.getVersion());

            artifacts.add(getArtifact(item));
        }
        buildDependencyTree(artifacts);
    }

    private void buildUmbrellaDependencyTrees() throws DependencyResolutionException, MojoExecutionException {
        log.debug("<<<<<<<<<<<< Building Umbrella Dependency Trees >>>>>>>>>>>");
        List<Artifact> artifacts = new ArrayList<Artifact>();
        ArtifactItem item = new ArtifactItem();

        //JavaEE
        item.setGroupId("javax");
        item.setArtifactId("javaee-api");
        item.setType("pom");
        String[] javaEEVersions = new String[] {"6.0", "7.0", "8.0", "8.0.1"};
        for (String version : javaEEVersions) {
            item.setVersion(version);
            artifacts.add(getArtifact(item));
        }
        //JakartaEE
        item.setGroupId("jakarta.platform");
        item.setArtifactId("jakarta.jakartaee-api");
        item.setType("pom");
        String[] jakartaEEVersions = new String[] {"8.0.0", "9.0.0", "9.1.0"};
        for (String version : jakartaEEVersions) {
            item.setVersion(version);
            artifacts.add(getArtifact(item));
        }
        //Microprofile
        item.setGroupId("org.eclipse.microprofile");
        item.setArtifactId("microprofile");
        item.setType("pom");
        String[] microprofileVersions = new String[] {"3.0", "3.1", "3.2", "3.3", "4.0", "4.0.1"};
        for (String version : microprofileVersions) {
            item.setVersion(version);
            artifacts.add(getArtifact(item));
        }

        buildDependencyTree(artifacts);
    }

    private void buildDependencyTree(List<Artifact> artifacts) throws DependencyResolutionException, MojoExecutionException {
        for (Artifact artifact : artifacts) {
            org.eclipse.aether.artifact.Artifact aetherArtifact = new org.eclipse.aether.artifact.DefaultArtifact(
                    artifact.getGroupId(), artifact.getArtifactId(), artifact.getType(), artifact.getVersion());
            org.eclipse.aether.graph.Dependency dependency = new org.eclipse.aether.graph.Dependency(aetherArtifact, null, true);

            CollectRequest collectRequest = new CollectRequest();
            collectRequest.setRoot(dependency);
            collectRequest.setRepositories(repositories);
            
            CollectResult collectResult;
            try {
                // builds the dependency graph without downloading actual artifact files
                collectResult = repositorySystem.collectDependencies(repoSession, collectRequest);
                org.eclipse.aether.graph.DependencyNode rootNode = collectResult.getRoot();
                log.info("<<<< Dependency Tree for " + rootNode.getArtifact().toString() + " >>>>");
                printDependencyTree(rootNode, "");
                log.info("------------------------------------------------------------------------------------------------------------------------------------");
            } catch (DependencyCollectionException e) {
                log.error("Could not collect dependencies", e);
            }
        }
    }

    private void printDependencyTree(org.eclipse.aether.graph.DependencyNode node, String space) {
        log.info(space + node.getArtifact().toString());
        for (org.eclipse.aether.graph.DependencyNode child : node.getChildren()) {
            printDependencyTree(child, space + " ");
        }
    }

    private void findDependencyVersion(String packageDep, String umbrellaDep) throws MojoExecutionException {
        String packageDepGroupId = packageDep.split(":")[0];
        String packageDepArtifactId = packageDep.split(":")[1];

        String umbrellaDepGroupId = umbrellaDep.split(":")[0];
        String umbrellaDepArtifactId = umbrellaDep.split(":")[1];
        String umbrellaDepVersion = umbrellaDep.split(":")[3];

        ArtifactItem item = new ArtifactItem();
        item.setGroupId(umbrellaDepGroupId);
        item.setArtifactId(umbrellaDepArtifactId);
        item.setType("pom");
        item.setVersion(umbrellaDepVersion);
        Artifact artifact = getArtifact(item);

        org.eclipse.aether.artifact.Artifact aetherArtifact = new org.eclipse.aether.artifact.DefaultArtifact(
                artifact.getGroupId(), artifact.getArtifactId(), artifact.getType(), artifact.getVersion());
        org.eclipse.aether.graph.Dependency dependency = new org.eclipse.aether.graph.Dependency(aetherArtifact, null, true);

        CollectRequest collectRequest = new CollectRequest();
        collectRequest.setRoot(dependency);
        collectRequest.setRepositories(repositories);
        
        CollectResult collectResult;
        try {
            // builds the dependency graph without downloading actual artifact files
            collectResult = repositorySystem.collectDependencies(repoSession, collectRequest);
            org.eclipse.aether.graph.DependencyNode rootNode = collectResult.getRoot();
            boolean dependencyFound = false;
            for (org.eclipse.aether.graph.DependencyNode child : rootNode.getChildren()) {
                if (child.getArtifact().getGroupId().equals(packageDepGroupId) &&
                    child.getArtifact().getArtifactId().equals(packageDepArtifactId)) {
                        log.info("Version for " + packageDep + " : " + child.getArtifact().getVersion());
                        dependencyFound = true;
                }
            }
            if (!dependencyFound) {
                log.info("Dependency not found under this umbrella dependency.");
            }
        } catch (DependencyCollectionException e) {
            log.error("Could not collect dependencies", e);
        }
    }

    private void filterDependency(String includesPattern) throws DependencyResolutionException, MojoExecutionException {
        log.debug("<<<<<<<<<<<< Finding Dependency Paths >>>>>>>>>>>");
        DependencyManagement dm = project.getDependencyManagement();
        List<Dependency> dependencies;
        if (dm != null) {
            dependencies = dm.getDependencies();
        }
        else {
            log.debug("DependencyManagement is null. Retrieve dependencies directly through project.");
            dependencies = project.getDependencies();
        }
        List<Artifact> artifacts = new ArrayList<Artifact>();
        for (Dependency dep : dependencies) {
            ArtifactItem item = new ArtifactItem();
            item.setGroupId(dep.getGroupId());
            item.setArtifactId(dep.getArtifactId());
            // force the collection to get only the pom, not the actual artifact type
            item.setType("pom");
            item.setVersion(dep.getVersion());

            artifacts.add(getArtifact(item));
        }

        List<List<org.eclipse.aether.graph.DependencyNode>> allPaths = new ArrayList<List<org.eclipse.aether.graph.DependencyNode>>();

        for (Artifact artifact : artifacts) {
            org.eclipse.aether.artifact.Artifact aetherArtifact = new org.eclipse.aether.artifact.DefaultArtifact(
                    artifact.getGroupId(), artifact.getArtifactId(), artifact.getType(), artifact.getVersion());
            org.eclipse.aether.graph.Dependency dependency = new org.eclipse.aether.graph.Dependency(aetherArtifact, null, true);

            CollectRequest collectRequest = new CollectRequest();
            collectRequest.setRoot(dependency);
            collectRequest.setRepositories(repositories);
            
            CollectResult collectResult;
            try {
                // builds the dependency graph without downloading actual artifact files
                collectResult = repositorySystem.collectDependencies(repoSession, collectRequest);

                org.eclipse.aether.graph.DependencyNode rootNode = collectResult.getRoot();
                org.eclipse.aether.graph.DependencyFilter depFilter = new org.eclipse.aether.util.filter.PatternInclusionsDependencyFilter(
                        includesPattern);
                org.eclipse.aether.util.graph.visitor.PathRecordingDependencyVisitor filteringVisitor = new org.eclipse.aether.util.graph.visitor.PathRecordingDependencyVisitor(
                        depFilter);
                rootNode.accept(filteringVisitor);
                List<List<org.eclipse.aether.graph.DependencyNode>> nodeList = filteringVisitor.getPaths();
                if (nodeList == null || nodeList.isEmpty()) {
                    log.debug("No Paths");
                } else {
                    for (List<org.eclipse.aether.graph.DependencyNode> pathList : nodeList) {
                        allPaths.add(pathList);
                        log.debug("Path added");
                    }
                }
            } catch (DependencyCollectionException e) {
                log.error("Could not collect dependencies", e);
            }
        }

        int i = 0;
        for (List<org.eclipse.aether.graph.DependencyNode> pathList : allPaths) {
            log.info("----------------------------------------------------------");
            log.info("<<< Path " + ++i + " >>>");
            for (org.eclipse.aether.graph.DependencyNode node : pathList) {
                log.info(node.getArtifact().toString());
            }
            log.info("----------------------------------------------------------");
        }
    }

    private void dependencyAnalysis() {
        log.debug("<<<<<<<<<<<< Starting New Dependency Analysis >>>>>>>>>>>");
        try {
            //alt analyzer creation
            //DefaultProjectDependencyAnalyzer analyzer = new DefaultProjectDependencyAnalyzer();
            //ProjectDependencyAnalyzer analyzer = new DefaultProjectDependencyAnalyzer();

            ProjectDependencyAnalysis analysis;
            analysis = createProjectDependencyAnalyzer().analyze( project );

            Set<Artifact> usedDeclared = new LinkedHashSet<>( analysis.getUsedDeclaredArtifacts() );
            Set<Artifact> usedUndeclared = new LinkedHashSet<>( analysis.getUsedUndeclaredArtifacts() );
            Set<Artifact> unusedDeclared = new LinkedHashSet<>( analysis.getUnusedDeclaredArtifacts() );

            logArtifacts(usedDeclared, "Used & Declared");
            logArtifacts(usedUndeclared, "Used & Undeclared");
            logArtifacts(unusedDeclared, "Unused & Declared");

            Map<Artifact, Set<String>> artifactClassMap = new LinkedHashMap<>( analysis.getArtifactClassMap() );
            Set<String> dependencyClasses = new HashSet<>( analysis.getDependencyClasses() );
            Set<String> testOnlyDependencyClasses = new HashSet<>( analysis.getTestOnlyDependencyClasses() );

            log.debug( "<<< ARTIFACT CLASS MAP >>>" );
            log.debug(artifactClassMap.toString());
            log.debug( "<<< DEPENDENCY CLASSES >>>" );
            log.debug(dependencyClasses.toString());
            log.debug( "<<< TEST ONLY CLASSES >>>" );
            log.debug(testOnlyDependencyClasses.toString());

            Set<Artifact> lookupDependencies = new LinkedHashSet<>();
            lookupDependencies.addAll(usedDeclared);
            lookupDependencies.addAll(usedUndeclared);
            lookupDependencies = removeTestArtifacts(lookupDependencies);

            Set<Artifact> umbrellaDependencies = new LinkedHashSet<>();
            umbrellaDependencies.addAll(getUmbrellaDependencies(lookupDependencies));
            logArtifacts(umbrellaDependencies, "Umbrella Dependencies");
            lookupDependencies.removeAll(umbrellaDependencies);
            logArtifacts(lookupDependencies, "LOOKUP DEPENDENCIES");

            Set<String> lookupClasses = getLookupClasses(artifactClassMap, dependencyClasses, testOnlyDependencyClasses, umbrellaDependencies);
            log.info( "<<< LOOKUP CLASSES >>>" );
            log.info(lookupClasses.toString());

            Set<String> lookupPackages = getLookupPackages(lookupClasses);
            log.info( "<<< LOOKUP PACKAGES >>>" );
            log.info(lookupPackages.toString());
        } catch (ProjectDependencyAnalyzerException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (MojoExecutionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private void logArtifacts(Set<Artifact> artifacts, String type) {
        log.info("<<<<< " + type + " >>>>>");
        log.info(type + " size: " + artifacts.size());
        for (Artifact a : artifacts) {
            log.info(a.toString());
        }
    }

    private Set<Artifact> removeTestArtifacts(Set<Artifact> artifacts) {
        Set<Artifact> testArtifacts = new LinkedHashSet<>();
        for (Artifact a : artifacts) {
            if(a.getScope().equals("test")) {
                testArtifacts.add(a);
            }
        }
        logArtifacts(testArtifacts, "Test Dependencies To Remove");
        artifacts.removeAll(testArtifacts);
        return artifacts;
    }

     /**
     * FROM: https://github.com/apache/maven-dependency-plugin/blob/a0ac6fedf87dec9ec3ca93dd83d28ef2828cb544/src/main/java/org/apache/maven/plugins/dependency/analyze/AbstractAnalyzeMojo.java#L258
     * @return {@link ProjectDependencyAnalyzer}
     * @throws MojoExecutionException in case of an error.
     */
    protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer()
        throws MojoExecutionException
    {

        final String role = ProjectDependencyAnalyzer.ROLE;
        final String roleHint = "default";

        try
        {
            DefaultPlexusContainer defaultContainer = new DefaultPlexusContainer();
            Context context = defaultContainer.getContext();
            final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );

            return (ProjectDependencyAnalyzer) container.lookup( role, roleHint );
        }
        catch ( Exception exception )
        {
            throw new MojoExecutionException( "Failed to instantiate ProjectDependencyAnalyser with role " + role
                + " / role-hint " + roleHint, exception );
        }
    }

    private Set<Artifact> getUmbrellaDependencies(Set<Artifact> artifacts) {
        Set<Artifact> umbrellaDependencies = new LinkedHashSet<>();
        for (Artifact a : artifacts) {
            if (a.getArtifactId().equals("jakarta.jakartaee-api") ||
                a.getArtifactId().equals("javaee-api")) {
                    umbrellaDependencies.add(a);
                }
        }
        return umbrellaDependencies;
    }
        
    private Set<String> getLookupClasses(Map<Artifact, Set<String>> artifactClassMap, Set<String> dependencyClasses, 
                                         Set<String> testOnlyDependencyClasses, Set<Artifact> umbrellaDependencies) {
        Set<String> lookupClasses = new HashSet<>();
        for (Artifact a : umbrellaDependencies) {
            Set<String> artifactClasses = artifactClassMap.get(a);
            for (String depClass : dependencyClasses) {
                if (artifactClasses.contains(depClass) && !testOnlyDependencyClasses.contains(depClass)) {
                    // may need to check for duplicates
                    lookupClasses.add(depClass);
                }
            }
        }
        return lookupClasses;
    }

    private Set<String> getLookupPackages(Set<String> lookupClasses) {
        Set<String> lookupPackages = new HashSet<>();
        for (String lookupClass : lookupClasses) {
            String[] packageSegments = lookupClass.split("\\.");
            String lookupPackage = lookupClass.replace("." + packageSegments[packageSegments.length - 1], "");
            if (!lookupPackages.contains(lookupPackage)) {
                lookupPackages.add(lookupPackage);
            }
        }
        return lookupPackages;
    }
}
