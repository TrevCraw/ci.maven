/**
 * (C) Copyright IBM Corporation 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.openliberty.tools.maven.server;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.DependencyManagement;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.ProjectBuildingException;
import org.apache.maven.project.ProjectBuildingResult;
import org.codehaus.mojo.pluginsupport.util.ArtifactItem;
import org.eclipse.aether.collection.CollectRequest;
import org.eclipse.aether.collection.CollectResult;
import org.eclipse.aether.collection.DependencyCollectionException;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.resolution.DependencyResolutionException;

import io.openliberty.tools.ant.FeatureManagerTask.Feature;
import io.openliberty.tools.ant.install.Version;
import io.openliberty.tools.common.plugins.config.ServerConfigDropinXmlDocument;
import io.openliberty.tools.common.plugins.util.InstallFeatureUtil;
import io.openliberty.tools.common.plugins.util.InstallFeatureUtil.ProductProperties;
import io.openliberty.tools.common.plugins.util.PluginExecutionException;
import io.openliberty.tools.common.plugins.util.PluginScenarioException;
import io.openliberty.tools.maven.BasicSupport;
import io.openliberty.tools.maven.InstallFeatureSupport;
import io.openliberty.tools.maven.server.types.FeatureLookupEntry;
import io.openliberty.tools.maven.server.types.FeatureLookupTable;

import org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalysis;
import org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalyzer;
import org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalyzerException;

import org.codehaus.plexus.PlexusContainer;
import org.codehaus.plexus.DefaultPlexusContainer;
import org.codehaus.plexus.PlexusConstants;
import org.codehaus.plexus.context.Context;

/**
 * This mojo generates the features required in the featureManager element in server.xml.
 * It examines the dependencies declared in the pom.xml and the features already declared
 * in the featureManager elements in the XML configuration files. Then it generates any
 * missing feature names and stores them in a new featureManager element in a new XML file.
 */
@Mojo(name = "generate-features", requiresDependencyCollection = ResolutionScope.COMPILE, requiresDependencyResolution = ResolutionScope.COMPILE)
public class GenerateFeaturesMojo extends InstallFeatureSupport {

    protected static final String PLUGIN_ADDED_FEATURES_FILE = "configDropins/overrides/liberty-plugin-added-features.xml";
    protected static final String HEADER = "# Generated by liberty-maven-plugin";

    @Parameter(property = "filterDependency", defaultValue = "false")
    private boolean filterDependency;

    @Parameter(property = "includes")
    private String includes;

    @Parameter(property = "openLibertyRepo")
    private String openLibertyRepo;

    @Parameter(property = "classes")
    private boolean classes;

    @Parameter(property = "analyzeDependencies", defaultValue = "false")
    private boolean analyzeDependencies;

    @Parameter(property = "end2end", defaultValue = "false")
    private boolean end2end;

    @Parameter(property = "bomFile")
    private String bomFile;

    @Parameter(property = "printTree", defaultValue = "false")
    private boolean printTree;

    @Parameter(property = "dep")
    private String dep;

    @Parameter(property = "pomToUse")
    private String pomToUse;

    // TODO add a strategy parameter: nearest public feature, or farthest public feature, or farthest-1?

    /*
     * (non-Javadoc)
     * @see org.codehaus.mojo.pluginsupport.MojoSupport#doExecute()
     */
    @Override
    protected void doExecute() throws Exception {
        if (printTree) {
            filterDependencyTree(dep);
            return;
        }
        if (analyzeDependencies) {
            dependencyAnalysis();
            return;
        }
        if (end2end) {
            runEndToEnd();
            return;
        }
        if(!initialize()) {
            return;
        }
        if (filterDependency) {
            if (openLibertyRepo == null) {
                openLibertyRepo = "../open-liberty";
            }
            File openLibertyRepoDir = new File(openLibertyRepo);
    
            if (!openLibertyRepoDir.exists()) {
                try {
                    throw new MojoExecutionException("open-liberty git repository must exist at " + openLibertyRepoDir.getCanonicalPath() + ", or use -DopenLibertyRepo to specify custom location");
                } catch (IOException e) {
                    throw new MojoExecutionException("open-liberty git repository must exist at " + openLibertyRepoDir.getAbsolutePath() + ", or use -DopenLibertyRepo to specify custom location");
                }
            }

            List<FeatureLookupEntry> featureLookupEntries = new ArrayList<FeatureLookupEntry>();
            FeatureLookupTable featureLookupTable = new FeatureLookupTable(featureLookupEntries);
            
            Set<String> publicFeatures = getPublicFeatures();
            if (includes == null) {
                Set<HashableArtifactItem> featureDefinedMavenArtifacts = getFeatureDefinedMavenArtifacts(openLibertyRepoDir);
                List<HashableArtifactItem> sortedArtifactItems = new ArrayList<HashableArtifactItem>(featureDefinedMavenArtifacts);
                Collections.sort(sortedArtifactItems, new ArtifactComparator());
                for (ArtifactItem artifactItem : sortedArtifactItems) {
                    FeatureLookupEntry featureLookupEntry = filterDependency(getFilter(artifactItem), publicFeatures);

                    if (featureLookupEntry != null) {
                        featureLookupEntries.add(featureLookupEntry);
                        if (classes) {
                            // resolve artifact file and list its zip contents
                            try {
                                Artifact artifact = getArtifact(artifactItem);
    
                                Set<String> packageNames = new HashSet<String>();
                                try (ZipFile zipFile = new ZipFile(artifact.getFile())) {
                                    Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
                                    while (zipEntries.hasMoreElements()) {
                                        ZipEntry element = zipEntries.nextElement();
                                        String name = element.getName();
                                        if (!element.isDirectory() && name.endsWith(".class")) {
                                            if (name.contains("/")) {
                                                packageNames.add(name.substring(0, name.lastIndexOf("/")));
                                            }
                                        }
                                    }
                                }
                                //log.info("Packages: " + packageNames);
                                featureLookupEntry.javaPackageNames = packageNames;
                            } catch (MojoExecutionException e) {
                                log.warn(e.getMessage());
                            }
                        }
                    }
                }
            } else {
                filterDependency(includes, publicFeatures);
            }

            createCSVFile(featureLookupTable);
        } else {
            generateFeatures();
        }
    }


    String[] HEADERS = { "javaPackageNames", "mavenDependency", "featureName", "occurrences", "conflicts"};
    public void createCSVFile(FeatureLookupTable featureLookupTable) throws IOException {
        FileWriter out = new FileWriter("lookuptable.csv");
        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT.withHeader(HEADERS))) {
            for (FeatureLookupEntry entry : featureLookupTable.entries) {
                printer.printRecord(entry.javaPackageNames, entry.mavenDependency, entry.featureName, entry.occurrences, entry.conflicts);
            }
        }
    }

    private class ArtifactComparator implements Comparator<HashableArtifactItem> {
        @Override
        public int compare(HashableArtifactItem a1, HashableArtifactItem a2) {
            return (a1.toString().compareTo(a2.toString()));
        }
    }

    private void recursiveAddFeaturesFiles(File dir, List<File> appendedResults) {
        // add all features files that are directly in this directory 
        File[] featureFilesArray = dir.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".feature");
            }
        });
        Collections.addAll(appendedResults, featureFilesArray);

        // then recursively call the same method on all of its children dirs
        File[] subFiles = dir.listFiles();
        if (subFiles == null) {
            return;
        }
        for (File subFile : subFiles) {
            if (subFile.isDirectory()) {
                recursiveAddFeaturesFiles(subFile, appendedResults);
            }
        }
    }

    private Set<HashableArtifactItem> getFeatureDefinedMavenArtifacts(File openLibertyRepoDir) throws Exception {
        // get list of all mavenCoordinate items from .feature files in OL repo
        File featureVisibilityDir = new File(openLibertyRepoDir, "dev/com.ibm.websphere.appserver.features/visibility");
        if (!featureVisibilityDir.exists()) {
            throw new MojoExecutionException(featureVisibilityDir.getAbsolutePath() + " does not exist. Ensure open-liberty git repository is cloned to " + openLibertyRepoDir.getAbsolutePath());
        }

        List<File> allFeatureFiles = new ArrayList<File>();
        recursiveAddFeaturesFiles(featureVisibilityDir, allFeatureFiles);

        //log.info("All features size " + allFeatureFiles.size());

        // unique set of artifact items (to avoid duplicates)
        Set<HashableArtifactItem> allArtifactItems = new HashSet<HashableArtifactItem>();

        for (File featureFile : allFeatureFiles) {
            //log.info(featureFile.getAbsolutePath());

            try {
                addArtifactsFromFeatureFile(featureFile, allArtifactItems);
            } catch (IOException e) {
                log.error("Could not read file " + featureFile, e);
            }
        }
        return allArtifactItems;
    }
    
    private void addArtifactsFromFeatureFile(File featureFile, Set<HashableArtifactItem> allArtifactItems) throws Exception {
        BufferedReader reader = new BufferedReader(new FileReader(featureFile));
        StringBuilder sb = new StringBuilder();
        while (reader.ready()) {
            sb.append(reader.readLine());
        }
        reader.close();
        String content = sb.toString();
        
        final String KEYWORD = "mavenCoordinates";
        Pattern p = Pattern.compile(KEYWORD + "=\"[^\"]*\"");
        Matcher m = p.matcher(content);
        while (m.find()) {
            String match = m.group();
            // get the part within quotes
            String coordinates = match.substring(KEYWORD.length() + 2, match.length() - 1);
            //log.info("File " + featureFile + " has mavenCoordinates " + coordinates);

            String[] tokens = coordinates.split(":");
            if (tokens.length != 3) {
                throw new MojoExecutionException("The string " + coordinates
                        + " is not a valid Maven coordinates string. Expected format is groupId:artifactId:version");
            }
            HashableArtifactItem item = new HashableArtifactItem();
            item.setGroupId(tokens[0]);
            item.setArtifactId((tokens[1]));
            item.setVersion(tokens[2]);
            allArtifactItems.add(item);
        }
    }

    /**
     * Hashable implementation of ArtifactItem.
     * Implements the equals and hashCode methods according to group, artifact, and version. 
     * Ignores other ArtifactItem fields.
     */
    private class HashableArtifactItem extends ArtifactItem {
        @Override
        public boolean equals(Object o) {
            if (!(o instanceof HashableArtifactItem)) {
                return false;
            }
            HashableArtifactItem other = (HashableArtifactItem) o;
            boolean eq = this.getGroupId().equals(other.getGroupId()) && this.getArtifactId().equals(other.getArtifactId()) && this.getVersion().equals(other.getVersion());
            return eq;
        }

        @Override
        public int hashCode() {
            return new HashCodeBuilder(11, 33). // randomly chosen odd numbers
            append(getGroupId()).
            append(getArtifactId()).
            append(getVersion()).
            toHashCode();
        }
    }

    private String getFilter(ArtifactItem artifact) {
        return artifact.getGroupId() + ":" + artifact.getArtifactId() + "::" + artifact.getVersion();
    }

    private String getFilter(Artifact artifact) {
        return artifact.getGroupId() + ":" + artifact.getArtifactId() + "::" + artifact.getVersion();
    }

    private void generateFeatures() throws PluginExecutionException {
        log.warn("warn");
        List<ProductProperties> propertiesList = InstallFeatureUtil.loadProperties(installDirectory);
        String openLibertyVersion = InstallFeatureUtil.getOpenLibertyVersion(propertiesList);
        log.warn("version:"+openLibertyVersion);

        InstallFeatureMojoUtil util;
        try {
            util = new InstallFeatureMojoUtil(new HashSet<String>(), propertiesList, openLibertyVersion, null);
        } catch (PluginScenarioException e) {
            log.debug("Exception creating the server utility object", e);
            log.error("Error attempting to generate server feature list.");
            return;
        }

        Set<String> visibleServerFeatures = util.getAllServerFeatures();
        log.warn("feature count="+visibleServerFeatures.size());

        Set<String> libertyFeatureDependencies = getFeaturesFromDependencies(project);
        log.warn("maven dependencies that are liberty features:"+libertyFeatureDependencies);

        // Remove project dependency features which are hidden.
        Set<String> visibleLibertyProjectDependencies = new HashSet<String>(libertyFeatureDependencies);
        visibleLibertyProjectDependencies.retainAll(visibleServerFeatures);
        log.warn("maven dependencies that are VALID liberty features:"+visibleLibertyProjectDependencies);

        File newServerXml = new File(serverDirectory, PLUGIN_ADDED_FEATURES_FILE);
        log.warn("New server xml file:"+newServerXml+". Now to delete this file if it exists.");
        newServerXml.delete(); // about to regenerate this file. Must be removed before getLibertyDirectoryPropertyFiles

        Map<String, File> libertyDirPropertyFiles;
        try {
            libertyDirPropertyFiles = BasicSupport.getLibertyDirectoryPropertyFiles(installDirectory, userDirectory, serverDirectory);
        } catch (IOException e) {
            // TODO restore the xml file just deleted above
            log.debug("Exception reading the server property files", e);
            log.error("Error attempting to generate server feature list. Ensure you can read the property files in the server installation directory.");
            return;
        }
        Set<String> existingFeatures = util.getServerFeatures(serverDirectory, libertyDirPropertyFiles);
        log.warn("Features in server.xml:"+existingFeatures);

        Set<String> missingLibertyFeatures = getMissingLibertyFeatures(visibleLibertyProjectDependencies,
				existingFeatures);
        log.warn("maven dependencies that are VALID liberty features but are missing from server.xml:"+missingLibertyFeatures);

        // Create specialized server.xml
        try {
            ServerConfigDropinXmlDocument configDocument = ServerConfigDropinXmlDocument.newInstance();
            configDocument.createComment(HEADER);
            for (String missing : missingLibertyFeatures) {
                log.warn("adding missing feature:"+missing);
                configDocument.createFeature(missing);
            }
            configDocument.writeXMLDocument(newServerXml);
            log.warn("Created file "+newServerXml);
        } catch(ParserConfigurationException | TransformerException | IOException e) {
            log.debug("Exception creating the server features file", e);
            log.error("Error attempting to create the server feature file. Ensure you can write to the server installation directory.");
            return;
        }
    }

    /**
     * Comb through the list of Maven project dependencies and find the ones which are 
     * Liberty features.
     * @param project  Current Maven project
     * @return List of names of dependencies
     */
    private Set<String> getFeaturesFromDependencies(MavenProject project) {
        Set<String> libertyFeatureDependencies = new HashSet<String>();
        List<Dependency> allProjectDependencies = project.getDependencies();
        for (Dependency d : allProjectDependencies) {
            String featureName = getFeatureName(d);
            if (featureName != null) {
                libertyFeatureDependencies.add(featureName);
            }
        }
        return libertyFeatureDependencies;
    }

    /**
     * From all the candidate project dependencies remove the ones already in server.xml
     * to make the list of the ones that are missing from server.xml.
     * @param visibleLibertyProjectDependencies
     * @param existingFeatures
     * @return
     */
	private Set<String> getMissingLibertyFeatures(Set<String> visibleLibertyProjectDependencies,
			Set<String> existingFeatures) {
		Set<String> missingLibertyFeatures = new HashSet<String>(visibleLibertyProjectDependencies);
        if (existingFeatures != null) {
            for (String s : visibleLibertyProjectDependencies) {
                // existingFeatures are all lower case
                if (existingFeatures.contains(s.toLowerCase())) {
                    missingLibertyFeatures.remove(s);
                }
            }
        }
		return missingLibertyFeatures;
	}

	/**
	 * Determine if a dependency is a Liberty feature or not
	 * @param mavenDependency  a Maven project dependency 
	 * @return the Liberty feature name if the input is a Liberty feature otherwise return null.
	 */
    private String getFeatureName(Dependency mavenDependency) {
        if (mavenDependency.getGroupId().equals("io.openliberty.features")) {
            return mavenDependency.getArtifactId();
        }
        return null;
    }

    private FeatureLookupEntry filterDependency(String includesPattern, Set<String> publicFeatures) throws DependencyResolutionException, MojoExecutionException {
        List<Artifact> artifacts = retrieveProjectArtifacts();
        List<List<org.eclipse.aether.graph.DependencyNode>> allPaths = new ArrayList<List<org.eclipse.aether.graph.DependencyNode>>();

        for (Artifact artifact : artifacts) {
            org.eclipse.aether.graph.DependencyNode rootNode = retrieveRootNode(artifact);
            org.eclipse.aether.graph.DependencyFilter depFilter = new org.eclipse.aether.util.filter.PatternInclusionsDependencyFilter(
                    includesPattern);
            org.eclipse.aether.util.graph.visitor.PathRecordingDependencyVisitor filteringVisitor = new org.eclipse.aether.util.graph.visitor.PathRecordingDependencyVisitor(
                    depFilter);
            rootNode.accept(filteringVisitor);
            List<List<org.eclipse.aether.graph.DependencyNode>> nodeList = filteringVisitor.getPaths();
            if (nodeList == null || nodeList.isEmpty()) {
                log.debug("No Paths");
            } else {
                for (List<org.eclipse.aether.graph.DependencyNode> pathList : nodeList) {
                    allPaths.add(pathList);
                    log.debug("Path added");
                }
            }
        }

        Map<String, Integer> publicFeatureOccurrences = new HashMap<String, Integer>();

        int i = 0;
        for (List<org.eclipse.aether.graph.DependencyNode> pathList : allPaths) {
            log.debug("----------------------------------------------------------");
            log.debug("<<< Path " + ++i + " >>>");
            // for each node within the path list, go up the dependencies until a public feature is found
            String publicFeature = null;
            for (int j = pathList.size() - 1; j>=0; j--) {
                org.eclipse.aether.graph.DependencyNode node = pathList.get(j);
                log.debug(node.getArtifact().toString());
                if (isPublicFeature(node, publicFeatures)) {
                    if (publicFeature == null) {
                        log.debug("- Found public feature!");
                        publicFeature = node.getArtifact().getArtifactId();
                        Integer previousOccurrences = publicFeatureOccurrences.get(publicFeature);
                        if (previousOccurrences == null) {
                            previousOccurrences = 0;
                        }
                        publicFeatureOccurrences.put(publicFeature, previousOccurrences + 1);
                    } else {
                        log.debug("- Ignoring parent");
                        // TODO keep track of this for reporting purposes
                    }
                }
            }
            log.debug("----------------------------------------------------------");
        }

        Map<String, VersionAndOccurrence> featureVersionOccurrencesMap = filterHighestVersionsOfPublicFeatures(publicFeatureOccurrences);
        featureVersionOccurrencesMap = fixKnownMappings(includesPattern, featureVersionOccurrencesMap);
        publicFeatureOccurrences = convertToFeaturesWithVersion(featureVersionOccurrencesMap);

        String mostCommonPublicFeature = null;
        int mostFeatureOccurrences = 0;
        log.debug("===== Keyset size " + publicFeatureOccurrences.keySet().size()); 
        for (String publicFeature : publicFeatureOccurrences.keySet()) {
            log.debug("===== Looking at feature " + publicFeature); 
            int occurrences = publicFeatureOccurrences.get(publicFeature);
            if (occurrences > mostFeatureOccurrences) {
                mostCommonPublicFeature = publicFeature;
                mostFeatureOccurrences = occurrences;
                log.debug("Feature " + mostCommonPublicFeature + " has " + mostFeatureOccurrences + " occurrences");
            }
        }
        FeatureLookupEntry featureLookupEntry = new FeatureLookupEntry();
        featureLookupEntry.mavenDependency = includesPattern;
        featureLookupEntry.featureName = mostCommonPublicFeature;
        if (publicFeatureOccurrences.size() > 1) {
            log.debug("Dependency [" + includesPattern + "] -> Feature [" + mostCommonPublicFeature + "].  Occurrences: " + publicFeatureOccurrences);
            featureLookupEntry.occurrences = publicFeatureOccurrences;
            findConflicts(mostFeatureOccurrences, publicFeatureOccurrences, featureLookupEntry);
        } else {
            log.debug("Dependency [" + includesPattern + "] -> Feature [" + mostCommonPublicFeature + "]");
        }
        return featureLookupEntry;
    }

    private Map<String, VersionAndOccurrence> filterHighestVersionsOfPublicFeatures(Map<String, Integer> origFeatures) {
        Map<String, VersionAndOccurrence> filtered = new HashMap<String, VersionAndOccurrence>(); // map from feature name without version, to the highest version and number of total occurrences for that feature regardless of version
        for (String origFeature : origFeatures.keySet()) {
            String featureWithoutVersion = getFeatureWithoutVersion(origFeature);
            VersionAndOccurrence tuple = filtered.get(featureWithoutVersion);
            // if this feature (without version) was found before, just add to its occurrences and track only the highest version in the filtered map
            if (tuple != null) {
                tuple.occurrences = tuple.occurrences + origFeatures.get(origFeature); // add to its occurrences
                BigDecimal newVersion = getFeatureVersion(origFeature);
                if (getFeatureVersion(origFeature).compareTo(tuple.version) > 0) {
                    tuple.version = newVersion;
                }
            } else {
                VersionAndOccurrence newTuple = new VersionAndOccurrence();
                newTuple.occurrences = origFeatures.get(origFeature);
                newTuple.version = getFeatureVersion(origFeature);
                filtered.put(featureWithoutVersion, newTuple);
            }
        }
        return filtered;
    }

    /**
     * Known mappings, excluding dependency version or feature version
     */
    enum KnownMappings {

        MYFACES("org.apache.myfaces.core:myfaces-api", "jsf"),
        REACTIVE_STREAMS("org.reactivestreams:reactive-streams", "mpReactiveStreams"),
        PERSISTENCE("org.eclipse.persistence:javax.persistence", "jpa"),
        CDI("javax.enterprise:cdi-api", "cdi");
    
        String dependency;
        String feature;
    
        KnownMappings(String dependency, String feature) {
            this.dependency = dependency;
            this.feature = feature;
        }
    }

    /**
     * 
     * @param mavenDependencyFilterString Maven dependency in filter format e.g. org.apache.myfaces.core:myfaces-api::2.2.12
     * @param origFeatures Original map of feature occurrences
     * @return Map of feature occurrences containing only the known mapping(s)
     */
    private Map<String, VersionAndOccurrence> fixKnownMappings(String mavenDependencyFilterString, Map<String, VersionAndOccurrence> origFeatures) {
        Map<String, VersionAndOccurrence> filtered = new HashMap<String, VersionAndOccurrence>();

        for (KnownMappings m : KnownMappings.values()) {
            String[] tokens = mavenDependencyFilterString.split(":");
            String search = mavenDependencyFilterString;
            if (tokens.length >= 1) {
                search = tokens[0] + ":" + tokens[1];
            }
            if (m.dependency.equals(search)) {
                // see if origFeatures has the mapped feature
                if (origFeatures.keySet().contains(m.feature)) {
                    filtered.put(m.feature, origFeatures.get(m.feature));
                    // return just with one entry
                    return filtered;
                }
            }
        }
        // otherwise return everything
        return origFeatures;
    }

    private class VersionAndOccurrence {
        BigDecimal version;
        Integer occurrences;
    }

    private Map<String, Integer> convertToFeaturesWithVersion(Map<String, VersionAndOccurrence> map) {
        Map<String, Integer> result = new HashMap<String, Integer>();
        for (String featureWithoutVersion : map.keySet()) {
            VersionAndOccurrence tuple = map.get(featureWithoutVersion);
            if (tuple.version != null) {
                result.put(featureWithoutVersion + "-" + tuple.version.toPlainString(), tuple.occurrences);
            }
        }
        return result;
    }

    private String getFeatureWithoutVersion(String feature) {
        int versionSplitIndex = feature.lastIndexOf("-");
        return versionSplitIndex != -1 ? feature.substring(0, versionSplitIndex) : feature;
    }

    private BigDecimal getFeatureVersion(String feature) {
        int versionSplitIndex = feature.lastIndexOf("-");
        return versionSplitIndex != -1 ? new BigDecimal(feature.substring(versionSplitIndex + 1, feature.length())) : null;
    }

    private void findConflicts(int mostFeatureOccurrences, Map<String, Integer> publicFeatureOccurrences, FeatureLookupEntry featureLookupEntry) {
        List<String> potentialConflicts = new ArrayList<String>();
        for (Map.Entry<String,Integer> entry : publicFeatureOccurrences.entrySet()) {
            if (entry.getValue() == mostFeatureOccurrences) {
                potentialConflicts.add(entry.getKey());
            }
        }
        if (potentialConflicts.size() > 1) {
            //log.info("===== CONFLICTS: " + potentialConflicts);
            featureLookupEntry.conflicts = potentialConflicts;
        }
    }

    // get set of public features artifactIds
    private Set<String> getPublicFeatures() {
        File featuresVisibilityDir = new File(openLibertyRepo, "dev/com.ibm.websphere.appserver.features/visibility");
        // get public folder
        File publicFolder = new File(featuresVisibilityDir, "public");
        File[] publicFeatures = publicFolder.listFiles(new FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.isDirectory();
            }
        });
        Set<String> result = new HashSet<String>();
        for (File f : publicFeatures) {
            // get folder names, populate list
            // TODO only add real features based on .feature file
            result.add(f.getName());
        }
        log.debug("Public features: " + result);
        return result;
    }

    private boolean isPublicFeature(DependencyNode node, Set<String> publicFeatures) {
        return publicFeatures.contains(node.getArtifact().getArtifactId());
    }

    private void dependencyAnalysis() {
        try {
            ProjectDependencyAnalysis analysis;
            analysis = createProjectDependencyAnalyzer().analyze( project );

            Set<Artifact> usedDeclared = new LinkedHashSet<>( analysis.getUsedDeclaredArtifacts() );
            Set<Artifact> usedUndeclared = new LinkedHashSet<>( analysis.getUsedUndeclaredArtifacts() );
            Set<Artifact> unusedDeclared = new LinkedHashSet<>( analysis.getUnusedDeclaredArtifacts() );

            logArtifacts(usedDeclared, "Used & Declared");
            logArtifacts(usedUndeclared, "Used & Undeclared");
            logArtifacts(unusedDeclared, "Unused & Declared");

            Map<Artifact, Set<String>> artifactClassMap = new LinkedHashMap<>( analysis.getArtifactClassMap() );
            Set<String> dependencyClasses = new HashSet<>( analysis.getDependencyClasses() );
            Set<String> testOnlyDependencyClasses = new HashSet<>( analysis.getTestOnlyDependencyClasses() );

            log.debug( "<<< ARTIFACT CLASS MAP >>>" );
            log.debug(artifactClassMap.toString());
            log.debug( "<<< DEPENDENCY CLASSES >>>" );
            log.debug(dependencyClasses.toString());
            log.debug( "<<< TEST ONLY CLASSES >>>" );
            log.debug(testOnlyDependencyClasses.toString());

            Set<Artifact> lookupDependencies = new LinkedHashSet<>();
            lookupDependencies.addAll(usedDeclared);
            lookupDependencies.addAll(usedUndeclared);
            lookupDependencies = removeTestArtifacts(lookupDependencies);

            Set<Artifact> umbrellaDependencies = new LinkedHashSet<>();
            umbrellaDependencies.addAll(getUmbrellaDependencies(lookupDependencies));
            logArtifacts(umbrellaDependencies, "Umbrella Dependencies");
            lookupDependencies.removeAll(umbrellaDependencies);
            logArtifacts(lookupDependencies, "LOOKUP DEPENDENCIES");

            Map<Artifact, Set<String>> lookupClassMap = getLookupClasses(artifactClassMap, dependencyClasses, testOnlyDependencyClasses, umbrellaDependencies);
            log.info( "<<< LOOKUP CLASSES >>>" );
            log.info(lookupClassMap.toString());

            Map<Artifact, Set<String>> lookupPackageMap = getLookupPackages(lookupClassMap);
            log.info( "<<< LOOKUP PACKAGES >>>" );
            log.info(lookupPackageMap.toString());
        } catch (ProjectDependencyAnalyzerException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (MojoExecutionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private void logArtifacts(Set<Artifact> artifacts, String type) {
        log.info("<<<<< " + type + " >>>>>");
        log.info(type + " size: " + artifacts.size());
        for (Artifact a : artifacts) {
            log.info(a.toString());
        }
    }

    private Set<Artifact> removeTestArtifacts(Set<Artifact> artifacts) {
        Set<Artifact> testArtifacts = new LinkedHashSet<>();
        for (Artifact a : artifacts) {
            if(a.getScope().equals("test")) {
                testArtifacts.add(a);
            }
        }
        //logArtifacts(testArtifacts, "Test Dependencies To Remove");
        artifacts.removeAll(testArtifacts);
        return artifacts;
    }

    private Set<Artifact> getUmbrellaDependencies(Set<Artifact> artifacts) {
        Set<Artifact> umbrellaDependencies = new LinkedHashSet<>();
        for (Artifact a : artifacts) {
            if (a.getArtifactId().equals("jakarta.jakartaee-api") ||
                a.getArtifactId().equals("javaee-api")) {
                    umbrellaDependencies.add(a);
                }
        }
        return umbrellaDependencies;
    }

    private Map<Artifact, Set<String>> getLookupClasses(Map<Artifact, Set<String>> artifactClassMap, Set<String> dependencyClasses, 
                                         Set<String> testOnlyDependencyClasses, Set<Artifact> umbrellaDependencies) {
        Map<Artifact, Set<String>> lookupClassMap = new LinkedHashMap<>();
        for (Artifact a : umbrellaDependencies) {
            Set<String> artifactClasses = artifactClassMap.get(a);
            Set<String> lookupClasses = new HashSet<>();
            for (String depClass : dependencyClasses) {
                if (artifactClasses.contains(depClass) && !testOnlyDependencyClasses.contains(depClass)) {
                    lookupClasses.add(depClass);
                }
            }
            lookupClassMap.put(a, lookupClasses);
        }
        return lookupClassMap;
    }

    private Map<Artifact, Set<String>> getLookupPackages(Map<Artifact, Set<String>> lookupClassMap) {
        Map<Artifact, Set<String>> lookupPackageMap = new LinkedHashMap<>();
        for (Artifact a : lookupClassMap.keySet()) {
            Set<String> lookupPackages = new HashSet<>();
            for (String lookupClass : lookupClassMap.get(a)) {
                String[] packageSegments = lookupClass.split("\\.");
                String lookupPackage = lookupClass.replace("." + packageSegments[packageSegments.length - 1], "");
                if (!lookupPackages.contains(lookupPackage)) {
                    lookupPackages.add(lookupPackage);
                }
            }
            lookupPackageMap.put(a, lookupPackages);
        }
        return lookupPackageMap;
    }

    /**
     * FROM: https://github.com/apache/maven-dependency-plugin/blob/a0ac6fedf87dec9ec3ca93dd83d28ef2828cb544/src/main/java/org/apache/maven/plugins/dependency/analyze/AbstractAnalyzeMojo.java#L258
     * @return {@link ProjectDependencyAnalyzer}
     * @throws MojoExecutionException in case of an error.
     */
    protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer()
        throws MojoExecutionException
    {

        final String role = ProjectDependencyAnalyzer.ROLE;
        final String roleHint = "default";

        try
        {
            DefaultPlexusContainer defaultContainer = new DefaultPlexusContainer();
            Context context = defaultContainer.getContext();
            final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );

            return (ProjectDependencyAnalyzer) container.lookup( role, roleHint );
        }
        catch ( Exception exception )
        {
            throw new MojoExecutionException( "Failed to instantiate ProjectDependencyAnalyser with role " + role
                + " / role-hint " + roleHint, exception );
        }
    }

    private void runEndToEnd() throws Exception {
        File openLibertyRepoDir = repoSetup();
        Map<Artifact, Set<String>> artifactPackageMap = getPackageMap(openLibertyRepoDir);

        /** Start of Analysis */

        ProjectDependencyAnalysis analysis;
        analysis = createProjectDependencyAnalyzer().analyze( project );

        Set<Artifact> lookupDependencies = getLookupDependencies(analysis);
        Set<Artifact> umbrellaDependencies = getUmbrellaDependencies(lookupDependencies);
        lookupDependencies.removeAll(umbrellaDependencies);
        logArtifacts(lookupDependencies, "LOOKUP DEPENDENCIES");

        Map<Artifact, Set<String>> lookupPackageMap = getLookupPackageMap(analysis, umbrellaDependencies);
        lookupPackageMap = convertToSlashes(lookupPackageMap);
        log.info( "<<< LOOKUP PACKAGES >>>" );
        log.info(lookupPackageMap.toString());

        /** End of Analysis */

        log.info( "<<< After Analysis >>>" );
        log.info("Project ID: " + project.getArtifactId());

        ProjectBuildingResult build = null;
        File buildFile = new File(bomFile);
        log.info("New build file: " + buildFile.toString());
        try {
            build = mavenProjectBuilder.build(buildFile,
                    session.getProjectBuildingRequest().setResolveDependencies(false));
        } catch (ProjectBuildingException e) {
            log.error("Could not parse pom.xml. " + e.getMessage());
            log.debug(e);
        }

        // set the updated project in current session
        MavenProject backupProject = project;
        if (build != null) {
            project = build.getProject();
            session.setCurrentProject(project);
        } else {
            log.info("New build is null");
        }

        log.info( "<<< Before Lookup >>>" );
        log.info("Project ID: " + project.getArtifactId());

        /** Start of Lookup */

        Set<FeatureLookupEntry> featureLookupEntries = new LinkedHashSet<>();
        Set<String> publicFeatures = getPublicFeatures();

        for (Artifact a : lookupDependencies) {
            FeatureLookupEntry featureLookupEntry = filterDependency(getFilter(a), publicFeatures);
            featureLookupEntries.add(featureLookupEntry);
        }

        log.info("<<<<< FEATURE LIST >>>>>");
        log.info("Size: " + featureLookupEntries.size());
        for (FeatureLookupEntry entry : featureLookupEntries) {
            if (entry.featureName != null && !entry.featureName.equals("")) {
                log.info(entry.featureName);
            }
        }

        Map<Artifact, Set<Artifact>> packageDeps = getPackageDependencies(lookupPackageMap, artifactPackageMap);
        log.info( "<<< Package Dependency Map >>>" );
        log.info(packageDeps.toString());

        Set<FeatureLookupEntry> packageFeatures = getPackageFeatures(packageDeps, publicFeatures);
        log.info("<<<<< PACKAGE FEATURE LIST >>>>>");
        log.info("Size: " + packageFeatures.size());
        for (FeatureLookupEntry entry : packageFeatures) {
            if (entry.featureName != null && !entry.featureName.equals("")) {
                log.info(entry.featureName);
            }
        }

        Set<FeatureLookupEntry> generateFeaturesList = new HashSet<>();
        generateFeaturesList.addAll(featureLookupEntries);
        generateFeaturesList.addAll(packageFeatures);
        log.info("<<<<< GENERATE FEATURES LIST >>>>>");
        for (FeatureLookupEntry entry : generateFeaturesList) {
            if (entry.featureName == null || entry.featureName.equals("")) {
                log.debug("No feature mapping for: " + entry.mavenDependency);
            } else {
                log.info(entry.featureName);
            }
        }

        /** End of Lookup */

        project = backupProject;
        session.setCurrentProject(backupProject);

        log.info( "<<< After Lookup >>>" );
        log.info("Project ID: " + project.getArtifactId());
    }

    private Set<Artifact> getLookupDependencies(ProjectDependencyAnalysis analysis) {
        Set<Artifact> usedDeclared = new LinkedHashSet<>( analysis.getUsedDeclaredArtifacts() );
        Set<Artifact> usedUndeclared = new LinkedHashSet<>( analysis.getUsedUndeclaredArtifacts() );
        Set<Artifact> unusedDeclared = new LinkedHashSet<>( analysis.getUnusedDeclaredArtifacts() );

        logArtifacts(usedDeclared, "Used & Declared");
        logArtifacts(usedUndeclared, "Used & Undeclared");
        logArtifacts(unusedDeclared, "Unused & Declared");

        Set<Artifact> lookupDependencies = new LinkedHashSet<>();
        lookupDependencies.addAll(usedDeclared);
        lookupDependencies.addAll(usedUndeclared);
        lookupDependencies = removeTestArtifacts(lookupDependencies);
        return lookupDependencies;
    }

    private Map<Artifact, Set<String>> getLookupPackageMap(ProjectDependencyAnalysis analysis, Set<Artifact> umbrellaDependencies) {
        Map<Artifact, Set<String>> artifactClassMap = new LinkedHashMap<>( analysis.getArtifactClassMap() );
        log.debug( "<<< ARTIFACT CLASS MAP >>>" );
        log.debug(artifactClassMap.toString());

        Set<String> dependencyClasses = new HashSet<>( analysis.getDependencyClasses() );
        log.debug( "<<< DEPENDENCY CLASSES >>>" );
        log.debug(dependencyClasses.toString());

        Set<String> testOnlyDependencyClasses = new HashSet<>( analysis.getTestOnlyDependencyClasses() );
        log.debug( "<<< TEST ONLY CLASSES >>>" );
        log.debug(testOnlyDependencyClasses.toString());

        Map<Artifact, Set<String>> lookupClassMap = getLookupClasses(artifactClassMap, dependencyClasses, testOnlyDependencyClasses, umbrellaDependencies);
        log.debug( "<<< LOOKUP CLASSES >>>" );
        log.debug(lookupClassMap.toString());

        Map<Artifact, Set<String>> lookupPackageMap = getLookupPackages(lookupClassMap);
        log.debug( "<<< LOOKUP PACKAGES >>>" );
        log.debug(lookupPackageMap.toString());
        return lookupPackageMap;
    }

    private File repoSetup() throws MojoExecutionException {
        if (openLibertyRepo == null) {
            openLibertyRepo = "../open-liberty";
        }
        File openLibertyRepoDir = new File(openLibertyRepo);

        if (!openLibertyRepoDir.exists()) {
            try {
                throw new MojoExecutionException("open-liberty git repository must exist at " + openLibertyRepoDir.getCanonicalPath() + ", or use -DopenLibertyRepo to specify custom location");
            } catch (IOException e) {
                throw new MojoExecutionException("open-liberty git repository must exist at " + openLibertyRepoDir.getAbsolutePath() + ", or use -DopenLibertyRepo to specify custom location");
            }
        }

        return openLibertyRepoDir;
    }

    private Map<Artifact, Set<Artifact>> getPackageDependencies(Map<Artifact, Set<String>> lookupPackageMap, Map<Artifact, Set<String>> artifactPackageMap) {
        Map<Artifact, Set<Artifact>> packageDepsMap = new HashMap<>();
        // Set up new map to enable adding Artifacts to the Set later
        for (Artifact umbrellaDep : lookupPackageMap.keySet()) {
            packageDepsMap.put(umbrellaDep, new HashSet<Artifact>());
        }

        for (Artifact mavenDep : artifactPackageMap.keySet()) {
            for (Artifact umbrellaDep : lookupPackageMap.keySet()) {
                for (String pkg : lookupPackageMap.get(umbrellaDep)) {
                    if (artifactPackageMap.get(mavenDep).contains(pkg)) {
                        packageDepsMap.get(umbrellaDep).add(mavenDep);
                    }
                }
            }
        }

        return packageDepsMap;
    }

    private Set<FeatureLookupEntry> getPackageFeatures(Map<Artifact, Set<Artifact>> packageDepsMap, Set<String> publicFeatures) throws DependencyResolutionException, MojoExecutionException {
        List<String> mvnDepList = new ArrayList<>();
        List<String> checkedList = new ArrayList<>();
        for (Artifact umbrellaDep : packageDepsMap.keySet()) {
            String umbrellaDepName = umbrellaDep.getGroupId() + ":" + umbrellaDep.getArtifactId() +
                                     ":pom:" + umbrellaDep.getVersion();
            for (Artifact mvnDep : packageDepsMap.get(umbrellaDep)) {
                if (mvnDep == null) {
                    continue;
                }
                String mvnDepName = mvnDep.getGroupId() + ":" + mvnDep.getArtifactId();
                if (!checkedList.contains(mvnDepName)) {
                    checkedList.add(mvnDepName);
                    String version = findDependencyVersion(mvnDepName, umbrellaDepName);
                    if (version!= null) {
                        log.info(mvnDepName + " version " + version);
                        mvnDepList.add(mvnDepName + "::" + version);
                    }
                    else {
                        log.info(mvnDepName + " not found under " + umbrellaDepName);
                    }
                }
            }
        }

        Set<FeatureLookupEntry> featureList = new HashSet<>();
        for (String dep : mvnDepList) {
            FeatureLookupEntry featureLookupEntry = filterDependency(dep, publicFeatures);
            featureList.add(featureLookupEntry);
        }
        return featureList;
    }

    private Map<Artifact, Set<String>> getPackageMap(File openLibertyRepoDir) throws Exception {
        Map<Artifact, Set<String>> packageMap = new HashMap<>();
        Set<HashableArtifactItem> featureDefinedMavenArtifacts = getFeatureDefinedMavenArtifacts(openLibertyRepoDir);
        List<HashableArtifactItem> sortedArtifactItems = new ArrayList<HashableArtifactItem>(featureDefinedMavenArtifacts);
        Collections.sort(sortedArtifactItems, new ArtifactComparator());

        //log.info("All artifacts: " + sortedArtifactItems.toString());

        for (ArtifactItem artifactItem : sortedArtifactItems) {
            // resolve artifact file and list its zip contents
            try {
                Artifact artifact = getArtifact(artifactItem);
                boolean printPackages = false;
                if ((artifact.getGroupId().equals("jakarta.enterprise") && artifact.getArtifactId().equals("jakarta.enterprise.cdi-api")) ||
                (artifact.getGroupId().equals("jakarta.ws.rs") && artifact.getArtifactId().equals("jakarta.ws.rs-api"))) {
                    log.info("Retrieving packages for: " + artifact.getArtifactId() + ":" + artifact.getVersion());
                    printPackages = true;
                }

                Set<String> packageNames = new HashSet<String>();
                try (ZipFile zipFile = new ZipFile(artifact.getFile())) {
                    Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
                    while (zipEntries.hasMoreElements()) {
                        ZipEntry element = zipEntries.nextElement();
                        String name = element.getName();
                        if (!element.isDirectory() && name.endsWith(".class")) {
                            if (name.contains("/")) {
                                packageNames.add(name.substring(0, name.lastIndexOf("/")));
                            }
                        }
                    }
                }
                if (printPackages) {
                    log.info("Packages: " + packageNames);
                }
                packageMap.put(artifact, packageNames);
            } catch (MojoExecutionException e) {
                log.warn(e.getMessage());
            }
        }
        return packageMap;
    }

    private Map<Artifact, Set<String>> convertToSlashes(Map<Artifact, Set<String>> packageMap) {
        for (Artifact key : packageMap.keySet()) {
            Set<String> oldList = packageMap.get(key);
            Set<String> newList = new HashSet<>();
            for (String pkg : oldList) {
                String newPkg = pkg.replace(".", "/");
                newList.add(newPkg);
            }
            packageMap.replace(key, newList);
        }
        //log.info("New Package Map");
        //log.info(packageMap.toString());
        return packageMap;
    }

    // packageDep example: org.eclipse.microprofile.health:microprofile-health-api
    // umbrellaDep example: org.eclipse.microprofile:microprofile:pom:3.0
    private String findDependencyVersion(String packageDep, String umbrellaDep) throws DependencyResolutionException, MojoExecutionException {
        String packageDepGroupId = packageDep.split(":")[0];
        String packageDepArtifactId = packageDep.split(":")[1];

        String umbrellaDepGroupId = umbrellaDep.split(":")[0];
        String umbrellaDepArtifactId = umbrellaDep.split(":")[1];
        String umbrellaDepVersion = umbrellaDep.split(":")[3];

        if (umbrellaDepGroupId.equals("jakarta.platform") && umbrellaDepArtifactId.equals("jakarta.jakartaee-api")
            && umbrellaDepVersion.equals("8.0.0")) {
                umbrellaDepGroupId = "javax";
                umbrellaDepArtifactId = "javaee-api";
                umbrellaDepVersion = "8.0";
        }

        ArtifactItem item = new ArtifactItem();
        item.setGroupId(umbrellaDepGroupId);
        item.setArtifactId(umbrellaDepArtifactId);
        item.setType("pom");
        item.setVersion(umbrellaDepVersion);
        Artifact artifact = getArtifact(item);

        org.eclipse.aether.graph.DependencyNode rootNode = retrieveRootNode(artifact);
        // an alternative to recursion search everytime would be to build a list of all child dependencies belonging to each umbrella feature
        // and just doing a simple search on the list
        String version = dependencyVersionSearch(rootNode, packageDepGroupId, packageDepArtifactId, "");
        return version;
    }

    private String dependencyVersionSearch(org.eclipse.aether.graph.DependencyNode node, String depGroupId, String depArtifactId, String dash) throws DependencyResolutionException, MojoExecutionException {
        log.debug(dash + node.toString());
        log.debug("Children List Size: " + node.getChildren().size());
        if (node.getArtifact().getGroupId().equals(depGroupId) &&
            node.getArtifact().getArtifactId().equals(depArtifactId)) {
                return node.getArtifact().getVersion();
        }
        else {
            if (node.getChildren().isEmpty()) {
                return null;
            }
            for (org.eclipse.aether.graph.DependencyNode child : node.getChildren()) {
                org.eclipse.aether.graph.DependencyNode resolvedNode = retrieveRootNode(child.getArtifact());
                String version = dependencyVersionSearch(resolvedNode, depGroupId, depArtifactId, dash + "-");
                if (version != null) {
                    return version;
                }
            }
            return null;
        }
    }

    private org.eclipse.aether.graph.DependencyNode retrieveRootNode(Artifact artifact) throws DependencyResolutionException, MojoExecutionException {
        org.eclipse.aether.artifact.Artifact aetherArtifact = new org.eclipse.aether.artifact.DefaultArtifact(
                artifact.getGroupId(), artifact.getArtifactId(), artifact.getType(), artifact.getVersion());
        return retrieveRootNode(aetherArtifact);
    }

    private org.eclipse.aether.graph.DependencyNode retrieveRootNode(org.eclipse.aether.artifact.Artifact artifact) throws DependencyResolutionException, MojoExecutionException {
        org.eclipse.aether.graph.Dependency dependency = new org.eclipse.aether.graph.Dependency(artifact, null, true);

        CollectRequest collectRequest = new CollectRequest();
        collectRequest.setRoot(dependency);
        collectRequest.setRepositories(repositories);
        
        CollectResult collectResult;
        try {
            // builds the dependency graph without downloading actual artifact files
            collectResult = repositorySystem.collectDependencies(repoSession, collectRequest);
            org.eclipse.aether.graph.DependencyNode rootNode = collectResult.getRoot();
            return rootNode;
        } catch (DependencyCollectionException e) {
            log.error("Could not collect dependencies", e);
            return null;
        }
    }

    private void filterDependencyTree(String includesPattern) throws DependencyResolutionException, MojoExecutionException {
        setPom(pomToUse);
        List<Artifact> artifacts = retrieveProjectArtifacts();
        List<List<org.eclipse.aether.graph.DependencyNode>> allPaths = new ArrayList<List<org.eclipse.aether.graph.DependencyNode>>();

        for (Artifact artifact : artifacts) {
            log.info("Artifact: " + artifact.toString());
            org.eclipse.aether.graph.DependencyNode rootNode = retrieveRootNode(artifact);
            log.info("Dependency Node: " + rootNode.toString());
            log.info("Dependency Node Children: " + rootNode.getChildren().toString());
            printNodeTree(rootNode, "");
            org.eclipse.aether.graph.DependencyFilter depFilter = new org.eclipse.aether.util.filter.PatternInclusionsDependencyFilter(
                    includesPattern);
            org.eclipse.aether.util.graph.visitor.PathRecordingDependencyVisitor filteringVisitor = new org.eclipse.aether.util.graph.visitor.PathRecordingDependencyVisitor(
                    depFilter);
            rootNode.accept(filteringVisitor);
            List<List<org.eclipse.aether.graph.DependencyNode>> nodeList = filteringVisitor.getPaths();
            if (nodeList == null || nodeList.isEmpty()) {
                log.debug("No Paths");
            } else {
                for (List<org.eclipse.aether.graph.DependencyNode> pathList : nodeList) {
                    allPaths.add(pathList);
                    log.debug("Path added");
                }
            }
        }

        log.info("Dependency paths for: " + includesPattern);
        int i = 0;
        for (List<org.eclipse.aether.graph.DependencyNode> pathList : allPaths) {
            log.info("----------------------------------------------------------");
            log.info("<<< Path " + ++i + " >>>");
            for (org.eclipse.aether.graph.DependencyNode node : pathList) {
                log.info(node.getArtifact().toString());
            }
            log.info("----------------------------------------------------------");
        }
    }

    private List<Artifact> retrieveProjectArtifacts() throws MojoExecutionException {
        DependencyManagement dm = project.getDependencyManagement();
        List<Dependency> dependencies;
        if (dm != null) {
            dependencies = dm.getDependencies();
        }
        else {
            log.debug("DependencyManagement is null. Retrieve dependencies directly through project.");
            dependencies = project.getDependencies();
        }
        List<Artifact> artifacts = new ArrayList<Artifact>();
        for (Dependency dep : dependencies) {
            ArtifactItem item = new ArtifactItem();
            item.setGroupId(dep.getGroupId());
            item.setArtifactId(dep.getArtifactId());
            // force the collection to get only the pom, not the actual artifact type
            item.setType("pom");
            item.setVersion(dep.getVersion());
            artifacts.add(getArtifact(item));
        }
        return artifacts;
    }

    private void setPom(String pom) {
        ProjectBuildingResult build = null;
        File buildFile = new File(project.getBasedir(), pom);
        log.info("New build file: " + buildFile.toString());
        try {
            build = mavenProjectBuilder.build(buildFile,
                    session.getProjectBuildingRequest().setResolveDependencies(false));
        } catch (ProjectBuildingException e) {
            log.error("Could not parse pom.xml. " + e.getMessage());
            log.debug(e);
        }
        if (build != null) {
            project = build.getProject();
            session.setCurrentProject(project);
        } else {
            log.info("New build is null");
        }
    }

    private void printNodeTree(org.eclipse.aether.graph.DependencyNode node, String dash) throws MojoExecutionException, DependencyResolutionException {
        log.info(dash + node.toString());
        //log.info("Children List Size: " + node.getChildren().size());

        for (org.eclipse.aether.graph.DependencyNode child : node.getChildren()) {
            org.eclipse.aether.graph.DependencyNode newNode = retrieveRootNode(child.getArtifact());
            printNodeTree(newNode, dash + "-");
        }
    }
}
